# temporalio-graphs — Codebase Review (2025-11-19)

Scope: end-to-end review of the Python port against the .NET `Temporalio.Graphs` reference, test run, and parity assessment. Environment: Python 3.11, uv-managed venv, repo at commit state on 2025-11-19.

## Test Run
- Command: `. .venv/bin/activate && pytest -v`
- Result: **545 passed, 1 failed**, 57 expected warnings; coverage 91.58% (threshold 80% met).
- Failure: `tests/test_public_api.py::TestAnalyzeWorkflowSignature::test_public_api_clean_minimal_export` — `__all__` exports extra symbols (`analyze_workflow_graph`, `MultiWorkflowPath`) beyond the expected minimal API.

## High-Severity Findings
- Public API mismatch blocks tests/release: `src/temporalio_graphs/__init__.py` currently exports `analyze_workflow_graph` and `MultiWorkflowPath`; spec expects only the 11 minimal symbols. Decision needed: shrink `__all__` or update the contract/tests.
- Path-explosion guard gap: single-workflow generation enforces `max_decision_points` but ignores `max_paths`; relaxing decision limit can still emit > `max_paths` paths without error. Cross-workflow inline mode does enforce `max_paths`.

## Parity Gaps vs .NET Reference
- Missing GraphBuildingContext options present in C#:
  - `PreserveDecisionId` (keep hashed IDs) — Python always simplifies to d0, d1…
  - `MermaidOnly` (suppress path list) — Python lacks an equivalent toggle.
- Missing compact Mermaid output (`ToMermaidCompactSyntax` in .NET). Python renderer only emits full verbose syntax.
- Runtime interceptor/mocking model not ported (Python uses static AST analysis). Integration story differs: no worker interceptor, no mocked activity returns, no runtime recording of data-dependent behavior.

## Status Updates (previously listed gaps now fixed)
- Signal/wait_condition support is implemented (`helpers.py`, `detector.py`, generator interleaving); earlier docs marking it “stub” are out of date.
- Path ordering bug addressed: generator now interleaves activities/decisions/signals by source line number (was “all activities then all decisions”).

## Architectural Notes
- Python port intentionally diverges from .NET: static analysis (<1 ms, no execution) vs runtime multi-run interception (2^n executions). Faster and safer, but cannot capture runtime-only behavior (dynamic activity names, data-driven loops).
- Cross-workflow analysis is a Python-only enhancement (reference/inline/subgraph expansion modes) absent in the original C# library.

## Recommendations / Next Steps
1) Resolve API surface: adjust `__all__` to the minimal contract or update tests/docs to include `analyze_workflow_graph` and `MultiWorkflowPath`.
2) Add parity options `preserve_decision_id` and `mermaid_only`, or document their removal as intentional changes.
3) Enforce `max_paths` during single-workflow path generation to prevent accidental path blowups.
4) Implement compact Mermaid rendering mode to match .NET (optional but improves parity).
5) Refresh docs (`docs/dotnet-python-port-gaps.md`, README notes) to reflect current signal support and fixed path ordering to avoid stale guidance.
